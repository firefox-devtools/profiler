/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

import { storeWithProfile } from '../fixtures/stores';
import * as ProfileViewSelectors from '../../reducers/profile-view';
import * as TimelineSelectors from '../../reducers/timeline-view';
import * as UrlStateSelectors from '../../reducers/url-state';
import { getProfileWithMarkers } from './fixtures/profiles';

import {
  changeCallTreeSearchString,
  changeHidePlatformDetails,
  addRangeFilter,
  changeInvertCallstack,
  updateProfileSelection,
  changeImplementationFilter,
} from '../../actions/profile-view';
import {
  changeFlameChartColorStrategy,
  changeTimelineMarkersExpandedThread,
  changeTimelineFlameChartExpandedThread,
} from '../../actions/timeline';
import { getCategoryByImplementation } from '../../profile-logic/color-categories';

const { selectedThreadSelectors } = ProfileViewSelectors;

describe('selectors/getStackTimingByDepthForFlameChart', function () {
  /**
   * This table shows off how a flame chart gets filtered to JS only, where the number is
   * the stack index, and P is platform code, and J javascript.
   *
   *            Unfiltered             ->             JS Only
   *   0-10-20-30-40-50-60-70-80-90-91      0-10-20-30-40-50-60-70-80-90-91 <- Timing (ms)
   *  ================================     ================================
   *  0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |     0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |
   *  1P 1P 1P 1P    1P 1P 1P 1P 1P  |                       1J 1J 1J 1J  |
   *     2P 2P 3P       4J 4J 4J 4J  |                          2J 2J     |
   *                       5J 5J     |                             3P     |
   *                          6P     |                             4J     |
   *                          7P     |
   *                          8J     |
   */

  it('computes unfiltered stack timing by depth', function () {
    const store = storeWithProfile();
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(store.getState());
    expect(stackTimingByDepth).toEqual([
      { start: [0], end: [91], stack: [0], length: 1 },
      { start: [0, 50], end: [40, 91], stack: [1, 1], length: 2 },
      { start: [10, 30, 60], end: [30, 40, 91], stack: [2, 3, 4], length: 3 },
      { start: [70], end: [90], stack: [5], length: 1 },
      { start: [80], end: [90], stack: [6], length: 1 },
      { start: [80], end: [90], stack: [7], length: 1 },
      { start: [80], end: [90], stack: [8], length: 1 },
    ]);
  });

  it('computes "Hide platform details" stack timing by depth', function () {
    const store = storeWithProfile();
    store.dispatch(changeHidePlatformDetails(true));
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(store.getState());

    expect(stackTimingByDepth).toEqual([
      { start: [0], end: [91], stack: [0], length: 1 },
      { start: [60], end: [91], stack: [1], length: 1 },
      { start: [70], end: [90], stack: [2], length: 1 },
      { start: [80], end: [90], stack: [3], length: 1 },
      { start: [80], end: [90], stack: [4], length: 1 },
    ]);
  });

  it('uses search strings', function () {
    const store = storeWithProfile();
    store.dispatch(changeCallTreeSearchString('javascript'));
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(store.getState());
    expect(stackTimingByDepth).toEqual([
      { start: [60], end: [91], stack: [0], length: 1 },
      { start: [60], end: [91], stack: [1], length: 1 },
      { start: [60], end: [91], stack: [4], length: 1 },
      { start: [70], end: [90], stack: [5], length: 1 },
      { start: [80], end: [90], stack: [6], length: 1 },
      { start: [80], end: [90], stack: [7], length: 1 },
      { start: [80], end: [90], stack: [8], length: 1 },
    ]);
  });

  /**
   * The inverted stack indices will not match this chart, as new indices will be
   * generated by the function that inverts the profile information.
   *
   *            Uninverted             ->             Inverted
   *   0-10-20-30-40-50-60-70-80-90-91      0-10-20-30-40-50-60-70-80-90-91 <- Timing (ms)
   *  ================================     ================================
   *  0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |     1P 2P 2P 3P 0P 1P 4J 5P 8J 4J
   *  1P 1P 1P 1P    1P 1P 1P 1P 1P  |     0P 1P 1P 1P    0P 1P 4P 7P 1P
   *     2P 2P 3P       4J 4J 4J 4J  |        0P 0P 0P       0P 1J 6P 0P
   *                       5J 5J     |                          0P 5J
   *                          6P     |                             4J
   *                          7P     |                             1P
   *                          8J     |                             0P
   */

  it('can handle inverted stacks', function () {
    const store = storeWithProfile();
    store.dispatch(changeInvertCallstack(true));
    const stackTimingByDepth = selectedThreadSelectors.getStackTimingByDepthForFlameChart(store.getState());
    expect(stackTimingByDepth).toEqual([
      {
        start: [0, 10, 30, 40, 50, 60, 70, 80, 90],
        end: [10, 30, 40, 50, 60, 70, 80, 90, 91],
        stack: [0, 2, 5, 8, 0, 9, 12, 16, 9],
        length: 9,
      },
      {
        start: [0, 10, 30, 50, 60, 70, 80, 90],
        end: [10, 30, 40, 60, 70, 80, 90, 91],
        stack: [1, 3, 6, 1, 10, 13, 17, 10],
        length: 8,
      },
      {
        start: [10, 30, 60, 70, 80, 90],
        end: [30, 40, 70, 80, 90, 91],
        stack: [4, 7, 11, 14, 18, 11],
        length: 6,
      },
      {
        start: [70, 80],
        end: [80, 90],
        stack: [15, 19],
        length: 2,
      },
      { start: [80], end: [90], stack: [20], length: 1 },
      { start: [80], end: [90], stack: [21], length: 1 },
      { start: [80], end: [90], stack: [22], length: 1 },
    ]);
  });
});

describe('selectors/getFuncStackMaxDepthForFlameChart', function () {
  it('calculates the max func depth and observes of platform-detail filters', function () {
    const store = storeWithProfile();
    const allSamplesMaxDepth = selectedThreadSelectors.getFuncStackMaxDepthForFlameChart(store.getState());
    expect(allSamplesMaxDepth).toEqual(6);
    store.dispatch(changeHidePlatformDetails(true));
    const jsOnlySamplesMaxDepth = selectedThreadSelectors.getFuncStackMaxDepthForFlameChart(store.getState());
    expect(jsOnlySamplesMaxDepth).toEqual(4);
  });

  it('acts upon the current range', function () {
    const store = storeWithProfile();
    store.dispatch(addRangeFilter(0, 20));
    const allSamplesMaxDepth = selectedThreadSelectors.getFuncStackMaxDepthForFlameChart(store.getState());
    expect(allSamplesMaxDepth).toEqual(2);
    store.dispatch(changeHidePlatformDetails(true));
    const jsOnlySamplesMaxDepth = selectedThreadSelectors.getFuncStackMaxDepthForFlameChart(store.getState());
    expect(jsOnlySamplesMaxDepth).toEqual(0);
  });
});

describe('selectors/getLeafCategoryStackTimingForFlameChart', function () {
  /**
   * This table shows off how stack timings get filtered to a single row by concurrent
   * color categories. P is platform code, J javascript baseline, and I is javascript
   * interpreter.
   *
   *            Unfiltered             ->      By Concurrent Leaf Category
   *   0-10-20-30-40-50-60-70-80-90-91      0-10-20-30-40-50-60-70-80-90-91 <- Timing (ms)
   *  ================================     ================================
   *  0P 0P 0P 0P 0P 0P 0P 0P 0P 0P  |     1P 1P 1P 1P 1P 1P 4J 4J 8I 4J  |
   *  1P 1P 1P 1P    1P 1P 1P 1P 1P  |
   *     2P 2P 3P       4J 4J 4J 4J  |
   *                       5J 5J     |
   *                          6P     |
   *                          7P     |
   *                          8I     |
   */
  it('gets the unfiltered leaf-stack timing by implementation', function () {
    const store = storeWithProfile();
    store.dispatch(changeFlameChartColorStrategy(getCategoryByImplementation));
    const leafStackTiming = selectedThreadSelectors.getLeafCategoryStackTimingForFlameChart(store.getState());

    expect(leafStackTiming).toEqual([
      {
        start: [0, 60, 80, 90],
        end: [60, 80, 90, 91],
        stack: [1, 4, 8, 4],
        length: 4,
      },
    ]);
  });
});

describe('actions/changeTimelineFlameChartExpandedThread', function () {
  it('can set one timeline flame chart thread as expanded', function () {
    const store = storeWithProfile();
    const threads = ProfileViewSelectors.getThreads(store.getState());

    function isExpanded(thread, threadIndex) {
      return TimelineSelectors.getIsFlameChartExpanded(store.getState(), threadIndex);
    }

    expect(threads.map(isExpanded)).toEqual([false, false, false]);

    store.dispatch(changeTimelineFlameChartExpandedThread(1, true));
    expect(threads.map(isExpanded)).toEqual([false, true, false]);

    store.dispatch(changeTimelineFlameChartExpandedThread(2, true));
    expect(threads.map(isExpanded)).toEqual([false, false, true]);

    store.dispatch(changeTimelineFlameChartExpandedThread(2, false));
    expect(threads.map(isExpanded)).toEqual([false, false, false]);
  });
});

describe('actions/changeTimelineMarkersExpandedThread', function () {
  it('can set one timeline markers thread as expanded', function () {
    const store = storeWithProfile();
    const threads = ProfileViewSelectors.getThreads(store.getState());

    function isExpanded(thread, threadIndex) {
      return TimelineSelectors.getAreMarkersExpanded(store.getState(), threadIndex);
    }
    // Timeline markers are open by default.
    expect(threads.map(isExpanded)).toEqual([true, true, true]);

    store.dispatch(changeTimelineMarkersExpandedThread(1, false));
    expect(threads.map(isExpanded)).toEqual([true, false, true]);

    store.dispatch(changeTimelineMarkersExpandedThread(2, false));
    expect(threads.map(isExpanded)).toEqual([true, false, false]);

    store.dispatch(changeTimelineMarkersExpandedThread(2, true));
    expect(threads.map(isExpanded)).toEqual([true, false, true]);
  });
});

describe('actions/changeImplementationFilter', function () {
  const store = storeWithProfile();

  it('is initially set to filter to all', function () {
    const filter = UrlStateSelectors.getImplementationFilter(store.getState());
    expect(filter).toEqual('combined');
  });

  it('can be changed to cpp', function () {
    store.dispatch(changeImplementationFilter('cpp'));
    const filter = UrlStateSelectors.getImplementationFilter(store.getState());
    expect(filter).toEqual('cpp');
  });
});

describe('actions/updateProfileSelection', function () {
  it('can update the selection with new values', function () {
    const store = storeWithProfile();

    const initialSelection = ProfileViewSelectors.getProfileViewOptions(store.getState()).selection;
    expect(initialSelection).toEqual({
      hasSelection: false,
      isModifying: false,
    });

    store.dispatch(updateProfileSelection({
      hasSelection: true,
      isModifying: false,
      selectionStart: 100,
      selectionEnd: 200,
    }));

    const secondSelection = ProfileViewSelectors.getProfileViewOptions(store.getState()).selection;
    expect(secondSelection).toEqual({
      hasSelection: true,
      isModifying: false,
      selectionStart: 100,
      selectionEnd: 200,
    });
  });
});

describe('selectors/getMarkerTiming', function () {
  function getMarkerTiming(testMarkers) {
    const profile = getProfileWithMarkers(testMarkers);
    const { getState } = storeWithProfile(profile);
    return selectedThreadSelectors.getMarkerTiming(getState());
  }

  it('has no marker timing if no markers are present', function () {
    expect(getMarkerTiming([])).toEqual([]);
  });

  describe('markers of the same name', function () {
    it('puts markers of the same time in two rows', function () {
      // The timing should look like this:
      // 'Marker Name': *------*
      //              : *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, {startTime: 0, endTime: 10}],
        ['Marker Name', 0, {startTime: 0, endTime: 10}],
      ]);
      expect(markerTiming).toHaveLength(2);
    });

    it('puts markers of disjoint times in one row', function () {
      // The timing should look like this:
      // 'Marker Name': *------*  *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, {startTime: 0, endTime: 10}],
        ['Marker Name', 0, {startTime: 15, endTime: 25}],
      ]);
      expect(markerTiming).toHaveLength(1);
    });

    it('puts markers of overlapping times in two rows', function () {
      // The timing should look like this:
      // 'Marker Name': *------*
      //              :     *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, {startTime: 0, endTime: 10}],
        ['Marker Name', 0, {startTime: 5, endTime: 15}],
      ]);
      expect(markerTiming).toHaveLength(2);
    });

    it('puts markers of inclusive overlapping times in two rows', function () {
      // The timing should look like this:
      // 'Marker Name': *--------*
      //              :   *---*
      const markerTiming = getMarkerTiming([
        ['Marker Name', 0, {startTime: 0, endTime: 20}],
        ['Marker Name', 0, {startTime: 5, endTime: 15}],
      ]);
      expect(markerTiming).toHaveLength(2);
    });
  });

  describe('markers of the different names', function () {
    it('puts them in different rows', function () {
      // The timing should look like this:
      // 'Marker Name A': *------*
      // 'Marker Name B':           *------*
      const markerTiming = getMarkerTiming([
        ['Marker Name A', 0, {startTime: 0, endTime: 10}],
        ['Marker Name B', 0, {startTime: 20, endTime: 30}],
      ]);
      expect(markerTiming).toHaveLength(2);
      expect(markerTiming[0].name).toBe('Marker Name A');
      expect(markerTiming[1].name).toBe('Marker Name B');
    });
  });
});
